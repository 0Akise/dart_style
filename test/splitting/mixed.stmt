40 columns                              |
>>> prefers to expand map over multi-line arguments
sendPort.send({'type': 'error', 'error': 'oops'});
<<<
sendPort.send({
  'type': 'error',
  'error': 'oops'
});
>>> prefers to wrap before "."
new Future.sync(() => callback('msg')).then(
    (result) => replyTo.send()).catchError((error) {});
<<<
new Future.sync(() => callback('msg'))
    .then((result) => replyTo.send())
    .catchError((error) {});
>>>
Stream readInput(AssetId id) => future((input) => input.read());
<<<
Stream readInput(AssetId id) =>
    future((input) => input.read());
>>> nested expression indentation
someFunctionName(argument, argument, argument,
    someOtherFunction(argument, argument, arg));
<<<
someFunctionName(argument, argument,
    argument, someOtherFunction(
        argument, argument, arg));
>>> does not extra indent when multiple levels of nesting happen on one line
someFunctionName(argument, argument, argument,
    some(other(function(argument, argument, arg))));
<<<
someFunctionName(argument, argument,
    argument, some(other(function(
        argument, argument, arg))));
>>> forces extra indent and lines, if later line needs it
callSomeMethod(innerFunction(argument, argument, argument), argument, argument, argument);
<<<
callSomeMethod(
    innerFunction(
        argument, argument, argument),
    argument, argument, argument);
>>> function inside a collection
[item, obj.method(argument).method(argument).method(() {body;}).another().another()];
<<<
[
  item,
  obj
      .method(argument)
      .method(argument)
      .method(() {
    body;
  }).another().another()
];
>>> wrap at nested binary operator
receiver.firstMethod().next((link) => longIdentifier == veryLongIdentifier);
<<<
receiver
    .firstMethod()
    .next((link) => longIdentifier ==
        veryLongIdentifier);